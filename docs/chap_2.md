# 二、数据的表示和存储

## 数值和编码

计算机中进行的数据转换过程如下所示：

![数据的“转换”](https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210404233659.png)

- 机器级数据分为两大类：
  - 数值数据：无符号、带符号整数、浮点数；
  - 非数值数据：逻辑数、各类字符。
- 计算机中所有的信息都采用二进制编码，因此存在以下两个概念：
  - 机器数：用二进制编码后的序列；
  - 真值：现实中真正的值。
- 数值数据的表示，即确定一个数值数据的真值有三个要素：
  - **进位计数制**：二、八、十、十六进制及其相互转换；
  - **定、浮点表示**：小数点的表示方法，有**定点整数/小数**、**浮点数**； 
  - **编码方案**：正负号的表示方法，有**原码**、**补码**、**反码**、**移码**。

### 进制间转换

- R进制到十进制：按“权”展开。
- 十进制到二进制（再到八或十六进制）：
  - 整数：“除基取余，上右下左”；
  - 小数：“乘基取整，上左下右”。

![进制转换过程示例](https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210405104052.png)

### 定点数与浮点数

- 计算机中只能通过约定位置来表示小数点：
  - **定点数**：小数点约定在固定位置的数；
    - **定点小数**：用以表示浮点数的尾数；
    - **定点整数**：用以表示整数，有带符号和无符号之分。
  - **浮点数**：小数点约定为可浮动的数。
- 任何实数都能写成：$X = (-1)^S \times M \times R^E$，其中：
  - $S$：符号位，取值为`0`或`1`；
  - $M$：**尾数（mantissa）**，为二进制定点小数；
  - $E$：**阶（exponent）**，为二进制定点整数；
  - $R$：**基数（radix）**，一般为取`2`的幂。 
- 浮点数也是通过定点数来表示的，数值数据的表示问题实际上是**定点数的编码问题**。
  
## 定点数的编码表示

### 原码和移码

- **原码**（Sign and Magnitude）：用最高位作为符号位来表示正负号，正数为`0`，负数为`1`，数值部分不变。
  - 缺陷：
    - `0`的表示不唯一；
    - 加减运算方式不统一；
    - 符号位需要额外处理，不利于硬件设计。
  - 浮点数的**尾数**是用原码定点小数表示。
- **移码**（Excess notion）：将每个数值加上一个偏置常数（Excess/bias），编码位数为$n$时，该常数通常取$2^{n-1}$或$2^{n-1} - 1$。
  - 例如，$n=4$时，bias取$2^3$，$-7 (+8) \sim 0001B$。
  - bias取$2^{n-1}$时，移码与补码最高位时是相反的。
  - 浮点数的**阶**是用移码表示，便于加减运算时的对阶操作（比较大小）。

### 模运算与补码

- 一个模运算系统中，一个数与其除以“模”后的余数等价。
  - 例如，在时钟这个模12系统里，$10 - 4 = 10 + 8 (mod 12)$，此时称$-4$的模12**补码**（2's complement）为$8$。
  - 负数的补码等于模减该负数的绝对值；
  - 对一确定的模，一个数减去小于模的另一个数，总可以用该数加上另一数负数的补码来代替。
- 计算机中的运算器就是一个模运算系统，运算器的位数为$n$，则为模$2^n$系统：

![计算机的模运算](https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210405124728.png)

- 补码的位数为$n$，则$[X]_c = 2^n + X \ (-2^n \le X \lt 2^n, mod \ 2^n)$。
  - 正数：符号位为`0`，数值部分不变；
  - 负数：符号位为`1`，数值部分**各位取反**，**末位加一**。
    - 简便方法：从右到左遇到的第一个1的前面各位取反。
- 变形补码（4’s complement）：双符号位，用于存放可能溢出的中间结果，如十进制`8`的变形补码为`01000`。
  
## C语言中的数据表示

### 整数

- 无符号整数（Unsigned integer）：编码中不含符号位。
- 带符号整数（Signed integer）：用补码表示。
- C编译器处理常量时的默认类型如下：

![常量的默认类型](https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210405154639.png)

### 浮点数

可以用科学计数法（Scientific Notation）对二进制实数表示为**规格化形式**（Normalized form）：

![二进制实数规格化形式](https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210405160123.png)

因此只要对尾数和指数分别编码，便可以表示一个浮点数。

当前所有的通用计算机都用**IEEE 754标准**来表示浮点数：

![浮点数的IEEE754表示](https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210405161956.png)

- $S$：符号位，占`1`位；
- $Exponent$：用移码表示的**阶**，单/双精度下分别占`8`/`11`位，对应的bias（$2^{n-1} - 1$）分别为`127`/`1023`，且全0和全1被用以表示特殊值；
- $Significand$：部分尾数，规格化的尾数最最高位都为`1`，隐含表示，单/双精度下分别有`1 + 23`/`52`位；
- 单精度下，真值的计算公式为：$(-1)^S \times (1 + Significand) \times 2 ^(Exponent - 127)$。

转换过程如下例所示：

![IEEE754表示示例](https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210405164406.png)

对于一些特殊值：
- 当阶码和尾数都为`0`时，根据符号位的不同分别表示$+0$和$-0$；
- 当阶码全为`1`，尾数全为`0`时，根据符号位的不同分别表示$+\infty$和$-\infty$；
  - 由此，浮点数除以`0`的结果是$+/-\infty$，而非溢出异常。
- 当阶码全为`1`，尾数为非`0`时，表示`NaN`，如`sqrt(-4.0) = NaN`；
- 当阶码全为`0`，尾数为非`0`时，表示的是`非规格化数`，即小于`1`的数。

从数轴上看计算机可表示的浮点数：

![数轴上看浮点数](https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210405170523.png)

- 计算机可表示的浮点数并非连续，而是离散的点；
- 往无穷大或无穷小方向，可表示的浮点数之间间隔越来大，即离原点越近，可表示的浮点数精度越高； 
- 因此很多浮点数都无法在计算机中精确表示，只能**舍入到一个可表示的近似值**。

## 非数值数据的表示

- 逻辑数据：用一位表示，N位二进制可表示N个逻辑数据。
  - 按位进行运算；
  - 计算机靠指令将其与数值数据区分开。
- 西文字符：常用**7位ASCII码**进行编码。
  -  0：48（0x30）
  -  A：65（0x41）
  -  a：97（0x61）
- 国际字符：GB2312-80字符集。

## 数据宽度与存储容量单位

- **比特**（bit，位）：计算机中处理、存储、传输信息的最小单位。
- **字节**（byte，B）：`1 B = 8 bits`，二进制信息的基本计量单位；
  - 现代计算机的存储器**按字节编址**，它是最小可寻址单位（Addressable Unit）。
- **字**（word）： 被处理信息的单位，用以度量数据类型的宽度。
- **字长**：数据通路的宽度，与字的宽度不一定相同。

- 容量中常用的单位有：`KB`、`MB`、`GB`、`TB`，进率为$2^10$。
- 通信带宽常用的单位有：`kb/s`、`Mb/s`、`Gb/s`、`Tb/s`，进率为$10^3$。

## 数据的字节排列

- **大端方式**（Big Endian）：**最高有效字节**（Most Significant Byte，MSB）所在的地址是数的地址。
- **小端方式**（Little Endian）：**最低有效字节**（Least Significant Byte，LSB）所在的地址是数的地址。

![大小端示例](https://raw.githubusercontent.com/Hugsy19/Picbed/master/img/20210405202544.png)

- `union`的所有成员都从低地址开始，可利用该特效测试CPU的排列方式：
  
```c
#include <stdio.h>

void main()
{
  union NUM {
    int a;
    char b;
  } num;

  num.a = 0x12345678;

  if (num.b = 0x12) {
    printf("Big Endian\n");
  } else {
    printf("Little Endian\n");
  }

  printf("num.b = 0x%X\n", num.b);
}
```
